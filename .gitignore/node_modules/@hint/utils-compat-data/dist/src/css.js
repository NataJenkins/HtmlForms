"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const postcss_1 = require("postcss");
const browser_compat_data_1 = require("./browser-compat-data");
const browsers_1 = require("./browsers");
const cache_1 = require("./cache");
const helpers_1 = require("./helpers");
const css_types_1 = require("./css-types");
const selectorParser = require('postcss-selector-parser');
const valueParser = require('postcss-value-parser');
const getTokens = (nodes) => {
    let tokens = [];
    for (const node of nodes) {
        if (node.type === 'function' || node.type === 'word') {
            const prefix = postcss_1.vendor.prefix(node.value);
            const unprefixed = postcss_1.vendor.unprefixed(node.value);
            tokens.push([prefix, unprefixed]);
        }
        if (node.nodes) {
            tokens = [...tokens, ...getTokens(node.nodes)];
        }
    }
    return tokens;
};
const getPartialValueUnsupported = (context, value, browsers) => {
    const prefix = postcss_1.vendor.prefix(value);
    const unprefixedValue = postcss_1.vendor.unprefixed(value);
    const tokens = getTokens(valueParser(value).nodes);
    for (const entry of Object.values(context)) {
        const matches = entry.__compat && entry.__compat.matches;
        if (!matches) {
            continue;
        }
        if (matches.regex_value && new RegExp(matches.regex_value).exec(unprefixedValue)) {
            return browsers_1.getUnsupportedBrowsers(entry, prefix, browsers, unprefixedValue);
        }
        if (matches.keywords) {
            for (const [tokenPrefix, tokenValue] of tokens) {
                if (matches.keywords.includes(tokenValue)) {
                    return browsers_1.getUnsupportedBrowsers(entry, tokenPrefix, browsers, tokenValue);
                }
            }
        }
        if (matches.regex_token) {
            const regexToken = matches.regex_token && new RegExp(matches.regex_token);
            for (const [tokenPrefix, tokenValue] of tokens) {
                if (regexToken && regexToken.exec(tokenValue)) {
                    return browsers_1.getUnsupportedBrowsers(entry, tokenPrefix, browsers, tokenValue);
                }
            }
        }
    }
    return null;
};
const getValueUnsupported = (context, property, value, browsers) => {
    const [data, prefix, unprefixed] = helpers_1.getFeatureData(context, value);
    if (data) {
        return browsers_1.getUnsupportedBrowsers(data, prefix, browsers, unprefixed);
    }
    if (property && css_types_1.types.has(property)) {
        for (const type of css_types_1.types.get(property)) {
            const result = getValueUnsupported(browser_compat_data_1.mdn.css.types[type], '', value, browsers);
            if (result) {
                return result;
            }
        }
    }
    return getPartialValueUnsupported(context, value, browsers);
};
exports.getDeclarationUnsupported = (feature, browsers) => {
    const key = `css-declaration:${feature.property}|${feature.value || ''}`;
    return cache_1.getCachedValue(key, browsers, () => {
        const [data, prefix, unprefixed] = helpers_1.getFeatureData(browser_compat_data_1.mdn.css.properties, feature.property);
        if (data && feature.value) {
            return getValueUnsupported(data, unprefixed, feature.value, browsers);
        }
        return browsers_1.getUnsupportedBrowsers(data, prefix, browsers, unprefixed);
    });
};
exports.getRuleUnsupported = (feature, browsers) => {
    return cache_1.getCachedValue(`css-rule:${feature.rule}`, browsers, () => {
        const [data, prefix, unprefixed] = helpers_1.getFeatureData(browser_compat_data_1.mdn.css['at-rules'], feature.rule);
        return browsers_1.getUnsupportedBrowsers(data, prefix, browsers, unprefixed);
    });
};
const getPseudoSelectorUnsupported = (value, browsers) => {
    const name = value.replace(/^::?/, '');
    return cache_1.getCachedValue(`css-pseudo-selector:${name}`, browsers, () => {
        const [data, prefix, unprefixed] = helpers_1.getFeatureData(browser_compat_data_1.mdn.css.selectors, name);
        return browsers_1.getUnsupportedBrowsers(data, prefix, browsers, unprefixed);
    });
};
exports.getSelectorUnsupported = (feature, browsers) => {
    const parser = selectorParser();
    const root = parser.astSync(feature.selector);
    const unsupported = {
        browsers: [],
        details: new Map()
    };
    root.walkPseudos((node) => {
        const result = getPseudoSelectorUnsupported(node.value, browsers);
        if (result) {
            unsupported.browsers = [...unsupported.browsers, ...result.browsers];
            for (const [browser, details] of result.details) {
                unsupported.details.set(browser, details);
            }
        }
    });
    return unsupported.browsers.length ? unsupported : null;
};
